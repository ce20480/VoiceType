#!/usr/bin/env python3
"""
Voice CLI - Voice-to-text for Claude Code terminal sessions.

Usage:
    voice-cli              # Record until silence, transcribe, type result
    voice-cli --no-sound   # Disable audio feedback
    voice-cli --no-numbers # Disable number word conversion
    voice-cli --model small.en  # Use a different model
"""

import sys
import os
import argparse

# Add src directory to path
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
SRC_DIR = os.path.join(os.path.dirname(SCRIPT_DIR), "src")
sys.path.insert(0, SRC_DIR)

from record import record_with_silence_detection, record_fixed_duration
from vad_record import record_with_vad
from transcribe import Transcriber
from number_words import convert_number_words
from output import type_text, type_text_via_clipboard, play_sound, notify, get_frontmost_app, press_enter


def check_enter_trigger(text: str, triggers: list) -> tuple:
    """
    Check if text ends with an enter trigger word.

    Args:
        text: The transcribed text
        triggers: List of trigger words (e.g., ["enter", "send"])

    Returns:
        Tuple of (cleaned_text, should_enter)
        - cleaned_text: Text with trigger word removed if found
        - should_enter: True if trigger word was found
    """
    text_lower = text.lower().rstrip()

    for trigger in triggers:
        # Check if text ends with trigger word (with word boundary)
        if text_lower.endswith(trigger):
            # Make sure it's a word boundary (space or start of string before trigger)
            prefix = text_lower[:-len(trigger)]
            if prefix == "" or prefix.endswith(" ") or prefix.endswith("."):
                # Remove the trigger word and trailing punctuation/space
                cleaned = text[:len(prefix)].rstrip(" .")
                return (cleaned, True)

    return (text, False)


def load_config():
    """
    Load configuration from ~/.voice-cli/config.yaml (preferred) or config.json.
    Falls back to defaults if no config exists or parsing fails.
    """
    import json
    config_dir = os.path.expanduser("~/.voice-cli")
    yaml_path = os.path.join(config_dir, "config.yaml")
    json_path = os.path.join(config_dir, "config.json")

    defaults = {
        "model": "base.en",
        "silence_duration": 2.0,
        "silence_threshold": "1%",  # Fallback for sox (background <1%, speech ~4%)
        "sound_feedback": True,
        "convert_numbers": True,
        "show_notifications": True,  # Visual feedback via macOS notifications
        "vad_mode": True,  # Use Silero VAD for intelligent speech detection (recommended)
        "vad_threshold": 0.5,  # VAD confidence threshold (0-1)
        "max_duration": 30,  # Safety cap for recording
        "duration": 5.0,  # Fallback fixed duration
        "auto_enter": True,  # Press Enter when trigger words detected at end
        "enter_triggers": ["enter", "send", "submit", "return"],  # Words that trigger Enter
    }

    # Try YAML first (preferred for human-readable config with comments)
    if os.path.exists(yaml_path):
        try:
            import yaml
            with open(yaml_path) as f:
                user_config = yaml.safe_load(f) or {}
            defaults.update(user_config)
            return defaults
        except ImportError:
            pass  # YAML not available, try JSON
        except Exception:
            pass  # Invalid YAML, try JSON

    # Fall back to JSON
    if os.path.exists(json_path):
        try:
            with open(json_path) as f:
                user_config = json.load(f) or {}
            defaults.update(user_config)
        except Exception:
            pass  # Invalid JSON, use defaults

    return defaults


def main():
    parser = argparse.ArgumentParser(
        description="Voice-to-text for terminal sessions"
    )
    parser.add_argument(
        "--no-sound",
        action="store_true",
        help="Disable audio feedback (Ping/Pop sounds)"
    )
    parser.add_argument(
        "--no-numbers",
        action="store_true",
        help="Disable number word to digit conversion"
    )
    parser.add_argument(
        "--model",
        default=None,
        choices=["tiny.en", "base.en", "small.en", "medium.en", "large-v3"],
        help="Whisper model to use (default: from config or base.en)"
    )
    parser.add_argument(
        "--duration",
        type=float,
        default=5.0,
        help="Recording duration in seconds (default: 5)"
    )
    parser.add_argument(
        "--no-vad",
        action="store_true",
        help="Disable Silero VAD, use fixed duration recording instead"
    )
    parser.add_argument(
        "--silence",
        type=float,
        default=None,
        help="Silence duration before stopping (seconds)"
    )
    parser.add_argument(
        "--vad-threshold",
        type=float,
        default=None,
        help="VAD speech confidence threshold (0-1, default: 0.5)"
    )
    parser.add_argument(
        "--debug",
        action="store_true",
        help="Print debug information instead of typing"
    )
    parser.add_argument(
        "--no-notify",
        action="store_true",
        help="Disable macOS notification popups"
    )
    parser.add_argument(
        "--no-enter",
        action="store_true",
        help="Disable auto-enter trigger words (send, enter, etc.)"
    )

    args = parser.parse_args()

    # Load config and override with CLI args
    config = load_config()

    model = args.model or config["model"]
    duration = args.duration or config.get("duration", 5.0)
    silence_duration = args.silence or config["silence_duration"]
    use_sound = not args.no_sound and config["sound_feedback"]
    convert_nums = not args.no_numbers and config["convert_numbers"]
    show_notify = not args.no_notify and config.get("show_notifications", True)
    use_vad = not args.no_vad and config.get("vad_mode", True)
    vad_threshold = args.vad_threshold or config.get("vad_threshold", 0.5)
    max_duration = config.get("max_duration", 30)
    auto_enter = not args.no_enter and config.get("auto_enter", True)
    enter_triggers = config.get("enter_triggers", ["enter", "send", "submit", "return"])

    try:
        # IMPORTANT: Save frontmost app BEFORE anything else
        # This is needed because Raycast may become frontmost when triggered
        original_app = get_frontmost_app()
        if args.debug:
            print(f"Frontmost app at start: {original_app}")

        # Pre-load VAD model BEFORE audio feedback
        # This ensures recording is truly ready when user hears Ping
        if use_vad:
            from vad_record import get_vad_model
            if args.debug:
                print("Pre-loading VAD model...")
            get_vad_model()  # Loads and caches the model
            if args.debug:
                print("VAD model ready")

        # Visual feedback: recording started
        if show_notify:
            if use_vad:
                notify("Voice CLI", "Recording... (auto-stops when you pause)")
            else:
                notify("Voice CLI", f"Recording for {duration}s... Speak now!")

        # Audio feedback: recording started (model is now ready!)
        if use_sound:
            play_sound("Ping")

        # Record audio - VAD by default (auto-stops when you stop speaking)
        if use_vad:
            try:
                audio_path = record_with_vad(
                    silence_duration=silence_duration,
                    max_duration=max_duration,
                    speech_threshold=vad_threshold
                )
            except Exception as e:
                # Fallback to fixed duration if VAD fails
                if args.debug:
                    print(f"VAD failed, using fixed duration: {e}")
                audio_path = record_fixed_duration(duration=duration)
        else:
            audio_path = record_fixed_duration(duration=duration)

        # Audio feedback: recording stopped, processing
        if use_sound:
            play_sound("Pop")

        # Check if audio file was created and has content
        if not os.path.exists(audio_path):
            if show_notify:
                notify("Voice CLI", "No audio file created")
            if args.debug:
                print("No audio recorded")
            return

        file_size = os.path.getsize(audio_path)
        if file_size < 1000:  # Less than 1KB, probably no speech
            if show_notify:
                notify("Voice CLI", f"No speech detected ({file_size} bytes)")
            if args.debug:
                print(f"Audio file too small ({file_size} bytes), no speech detected")
            os.remove(audio_path)
            return

        # Visual feedback: transcribing
        if show_notify:
            notify("Voice CLI", "Transcribing...")

        # Transcribe
        text = Transcriber.transcribe(audio_path, model_name=model)

        if not text:
            if show_notify:
                notify("Voice CLI", "No text transcribed")
            if args.debug:
                print("No text transcribed")
            os.remove(audio_path)
            return

        # Convert number words to digits
        if convert_nums:
            text = convert_number_words(text)

        # Check for enter trigger words (e.g., "send", "enter")
        should_enter = False
        if auto_enter:
            text, should_enter = check_enter_trigger(text, enter_triggers)

        if args.debug:
            print(f"Transcribed: {text}")
            print(f"Model: {model}")
            print(f"Audio size: {file_size} bytes")
            print(f"Target app: {original_app}")
            print(f"Should enter: {should_enter}")
            if show_notify:
                notify("Voice CLI", f"Done: {text[:50]}...")
        else:
            # Type the result into the original app using clipboard method
            # This is more reliable when triggered from Raycast
            if text:  # Only paste if there's text after removing trigger
                type_text_via_clipboard(text, target_app=original_app)

            # Press Enter if trigger word was detected
            if should_enter:
                import time
                time.sleep(0.05)  # Small delay to ensure paste completes
                press_enter()

            if show_notify:
                action = "Sent" if should_enter else "Typed"
                notify("Voice CLI", f"{action}: {text[:50]}...")

        # Cleanup
        os.remove(audio_path)

    except KeyboardInterrupt:
        if args.debug:
            print("\nCancelled")
        sys.exit(0)
    except FileNotFoundError as e:
        if show_notify:
            notify("Voice CLI Error", str(e))
        print(f"Error: {e}", file=sys.stderr)
        print("Make sure sox is installed: brew install sox", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        if show_notify:
            notify("Voice CLI Error", str(e)[:100])
        print(f"Error: {e}", file=sys.stderr)
        if args.debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
